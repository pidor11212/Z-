//beta(launch in cxxdroid) 
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <cmath>
#include <ctime>
#include <chrono>
#include <sstream>
#include <algorithm>
#include <random>
#include <iomanip>
#include <thread>

#ifdef __ANDROID__
#include <android/log.h>
#endif

using namespace std;
using namespace chrono;

class ZSharp {
private:
    map<string, double> variables;
    vector<string> program;
    int loop_counter;
    bool debug_mode;
    random_device rd;
    mt19937 gen;
    double exec_time;
    int line_count;
    
    const string RED = "\033[31m";
    const string GREEN = "\033[32m";
    const string YELLOW = "\033[33m";
    const string BLUE = "\033[34m";
    const string MAGENTA = "\033[35m";
    const string CYAN = "\033[36m";
    const string RESET = "\033[0m";
    
public:
    ZSharp() : gen(rd()) {
        loop_counter = 0;
        debug_mode = false;
        exec_time = 0;
        line_count = 0;
        
        // –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
        variables["pi"] = 3.141592653589793;
        variables["e"] = 2.718281828459045;
        variables["million"] = 1000000;
        variables["billion"] = 1000000000;
        
        cout << "\n";
        cout << "  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó" << endl;
        cout << "  ‚ïö‚ïê‚ïê‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë" << endl;
        cout << "    ‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë" << endl;
        cout << "   ‚ñà‚ñà‚ñà‚ïî‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë" << endl;
        cout << "  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ïë" << endl;
        cout << "  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù     ‚ïö‚ïê‚ïù" << endl;
        cout << "  Z# (–ó–∏ –®–∞—Ä–ø) v3.0" << endl;
        cout << "  ==================" << endl;
        cout << "  –ù–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã: count, bench, speed" << endl;
        cout << "\n";
    }
    
    string trim(const string& str) {
        size_t first = str.find_first_not_of(" \t");
        if (first == string::npos) return "";
        size_t last = str.find_last_not_of(" \t");
        return str.substr(first, last - first + 1);
    }
    
    double evaluateExpression(const string& expr) {
        string e = trim(expr);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        if (variables.find(e) != variables.end()) {
            return variables[e];
        }
        
        // –ü—Ä–æ–±—É–µ–º —á–∏—Å–ª–æ
        try {
            return stod(e);
        } catch (...) {}
        
        // –ü—Ä–æ—Å—Ç–æ–π –ø–∞—Ä—Å–µ—Ä –≤—ã—Ä–∞–∂–µ–Ω–∏–π
        vector<char> ops;
        vector<string> tokens;
        string current;
        
        for (char c : e) {
            if (c == '+' || c == '-' || c == '*' || c == '/') {
                if (!current.empty()) {
                    tokens.push_back(current);
                    current.clear();
                }
                ops.push_back(c);
            } else {
                current += c;
            }
        }
        if (!current.empty()) {
            tokens.push_back(current);
        }
        
        if (tokens.empty()) return 0;
        if (tokens.size() == 1) {
            if (variables.find(tokens[0]) != variables.end()) {
                return variables[tokens[0]];
            }
            try {
                return stod(tokens[0]);
            } catch (...) {
                return 0;
            }
        }
        
        double result = 0;
        for (size_t i = 0; i < tokens.size(); i++) {
            double val;
            if (variables.find(tokens[i]) != variables.end()) {
                val = variables[tokens[i]];
            } else {
                try {
                    val = stod(tokens[i]);
                } catch (...) {
                    val = 0;
                }
            }
            
            if (i == 0) {
                result = val;
            } else {
                char op = ops[i-1];
                switch (op) {
                    case '+': result += val; break;
                    case '-': result -= val; break;
                    case '*': result *= val; break;
                    case '/': if (val != 0) result /= val; break;
                }
            }
        }
        
        return result;
    }
    
    // –ù–û–í–ê–Ø –ö–û–ú–ê–ù–î–ê: count - –ø–æ–¥—Å—á–µ—Ç –¥–æ —á–∏—Å–ª–∞
    void executeCount(const string& line) {
        // –§–æ—Ä–º–∞—Ç—ã:
        // count 1000000
        // count to 1000000
        // count from 1 to 1000000
        // count with step 2 to 1000000
        
        string l = line.substr(5); // —É–±–∏—Ä–∞–µ–º "count"
        l = trim(l);
        
        long long start_val = 0;
        long long end_val = 0;
        long long step = 1;
        bool show_progress = true;
        
        // –ü–∞—Ä—Å–∏–º —Ä–∞–∑–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã
        if (l.substr(0, 2) == "to") {
            // count to 1000000
            end_val = (long long)evaluateExpression(l.substr(2));
        }
        else if (l.substr(0, 4) == "from") {
            // count from 1 to 1000000
            size_t to_pos = l.find("to");
            if (to_pos != string::npos) {
                string from_part = l.substr(4, to_pos - 4);
                string to_part = l.substr(to_pos + 2);
                
                start_val = (long long)evaluateExpression(from_part);
                end_val = (long long)evaluateExpression(to_part);
            }
        }
        else if (l.find("step") != string::npos) {
            // count with step 2 to 1000000
            size_t step_pos = l.find("step");
            size_t to_pos = l.find("to");
            
            if (step_pos != string::npos && to_pos != string::npos) {
                string step_part = l.substr(step_pos + 4, to_pos - step_pos - 4);
                string to_part = l.substr(to_pos + 2);
                
                step = (long long)evaluateExpression(step_part);
                end_val = (long long)evaluateExpression(to_part);
            }
        }
        else {
            // count 1000000 (–ø—Ä–æ—Å—Ç–æ —á–∏—Å–ª–æ)
            end_val = (long long)evaluateExpression(l);
        }
        
        // –ï—Å–ª–∏ end_val –Ω–µ –∑–∞–¥–∞–Ω–æ, –±–µ—Ä–µ–º –∏–∑ l
        if (end_val == 0) {
            end_val = (long long)evaluateExpression(l);
        }
        
        cout << CYAN << "\nüìä –ü–æ–¥—Å—á–µ—Ç –¥–æ " << end_val << "..." << RESET << endl;
        cout << "   –°—Ç–∞—Ä—Ç: " << start_val << ", –®–∞–≥: " << step << endl;
        cout << "----------------------------------------" << endl;
        
        auto start_time = high_resolution_clock::now();
        
        // –°–ê–ú –ü–û–î–°–ß–ï–¢
        volatile long long counter = start_val;
        long long last_progress = 0;
        
        if (step > 0) {
            for (long long i = start_val; i < end_val; i += step) {
                counter = i;
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∫–∞–∂–¥—ã–µ 10%
                if (show_progress && end_val > 1000000) {
                    long long progress = (i - start_val) * 100 / (end_val - start_val);
                    if (progress >= last_progress + 10) {
                        last_progress = progress;
                        auto now = high_resolution_clock::now();
                        auto elapsed = duration_cast<milliseconds>(now - start_time).count();
                        cout << "   " << progress << "% - " 
                             << i << " (" << elapsed / 1000.0 << " —Å–µ–∫)" << endl;
                    }
                }
            }
        }
        
        auto end_time = high_resolution_clock::now();
        auto duration = duration_cast<milliseconds>(end_time - start_time);
        
        cout << "----------------------------------------" << endl;
        cout << GREEN << "‚úÖ –ì–æ—Ç–æ–≤–æ!" << RESET << endl;
        cout << "   –ü–æ—Å–ª–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: " << counter << endl;
        cout << "   –í—Ä–µ–º—è: " << fixed << setprecision(3) 
             << duration.count() / 1000.0 << " —Å–µ–∫—É–Ω–¥" << endl;
        
        double speed = (end_val - start_val) / (duration.count() / 1000.0);
        cout << "   –°–∫–æ—Ä–æ—Å—Ç—å: " << (long long)speed << " –æ–ø–µ—Ä–∞—Ü–∏–π/—Å–µ–∫" << endl;
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
        variables["last_count"] = counter;
        variables["count_time"] = duration.count() / 1000.0;
        variables["count_speed"] = speed;
    }
    
    // –ù–û–í–ê–Ø –ö–û–ú–ê–ù–î–ê: bench - –±–µ–Ω—á–º–∞—Ä–∫
    void executeBench(const string& line) {
        string l = line.substr(5); // —É–±–∏—Ä–∞–µ–º "bench"
        l = trim(l);
        
        long long operations = 1000000; // –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        
        if (!l.empty()) {
            operations = (long long)evaluateExpression(l);
        }
        
        cout << CYAN << "\n‚ö° –ë–µ–Ω—á–º–∞—Ä–∫ –Ω–∞ " << operations << " –æ–ø–µ—Ä–∞—Ü–∏–π..." << RESET << endl;
        cout << "----------------------------------------" << endl;
        
        auto start_time = high_resolution_clock::now();
        
        // –†–∞–∑–Ω—ã–µ —Ç–µ—Å—Ç—ã
        cout << "   –¢–µ—Å—Ç 1: –ü—É—Å—Ç–æ–π —Ü–∏–∫–ª" << endl;
        volatile long long dummy = 0;
        for (long long i = 0; i < operations; i++) {
            dummy++;
        }
        
        auto test1_time = high_resolution_clock::now();
        auto ms1 = duration_cast<milliseconds>(test1_time - start_time).count();
        
        cout << "   –¢–µ—Å—Ç 2: –°–ª–æ–∂–µ–Ω–∏–µ" << endl;
        long long sum = 0;
        for (long long i = 0; i < operations; i++) {
            sum += i;
        }
        
        auto test2_time = high_resolution_clock::now();
        auto ms2 = duration_cast<milliseconds>(test2_time - test1_time).count();
        
        cout << "   –¢–µ—Å—Ç 3: –£–º–Ω–æ–∂–µ–Ω–∏–µ" << endl;
        long long mult = 1;
        for (long long i = 1; i < operations; i++) {
            mult *= (i % 100) + 1;
        }
        
        auto test3_time = high_resolution_clock::now();
        auto ms3 = duration_cast<milliseconds>(test3_time - test2_time).count();
        
        cout << "----------------------------------------" << endl;
        cout << GREEN << "üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã:" << RESET << endl;
        cout << "   –ü—É—Å—Ç–æ–π —Ü–∏–∫–ª: " << ms1 << " –º—Å (" 
             << (operations * 1000 / ms1) << " ops/sec)" << endl;
        cout << "   –°–ª–æ–∂–µ–Ω–∏–µ: " << ms2 << " –º—Å (" 
             << (operations * 1000 / ms2) << " ops/sec)" << endl;
        cout << "   –£–º–Ω–æ–∂–µ–Ω–∏–µ: " << ms3 << " –º—Å (" 
             << (operations * 1000 / ms3) << " ops/sec)" << endl;
    }
    
    // –ö–û–ú–ê–ù–î–ê speed - –ø–æ–∫–∞–∑–∞—Ç—å —Å–∫–æ—Ä–æ—Å—Ç—å —Å–∏—Å—Ç–µ–º—ã
    void executeSpeed() {
        cout << CYAN << "\nüöÄ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ Z#" << RESET << endl;
        cout << "----------------------------------------" << endl;
        
        // –¢–µ—Å—Ç 1: –ú–∞–ª–µ–Ω—å–∫–∏–π —Ü–∏–∫–ª
        auto start = high_resolution_clock::now();
        volatile int small = 0;
        for (int i = 0; i < 1000000; i++) { small++; }
        auto end = high_resolution_clock::now();
        auto ms = duration_cast<milliseconds>(end - start).count();
        cout << "   1 –º–ª–Ω –∏—Ç–µ—Ä–∞—Ü–∏–π: " << ms << " –º—Å" << endl;
        
        // –¢–µ—Å—Ç 2: –°—Ä–µ–¥–Ω–∏–π —Ü–∏–∫–ª
        start = high_resolution_clock::now();
        volatile long long medium = 0;
        for (long long i = 0; i < 10000000; i++) { medium++; }
        end = high_resolution_clock::now();
        ms = duration_cast<milliseconds>(end - start).count();
        cout << "   10 –º–ª–Ω –∏—Ç–µ—Ä–∞—Ü–∏–π: " << ms << " –º—Å" << endl;
        
        // –¢–µ—Å—Ç 3: –ë–æ–ª—å—à–æ–π —Ü–∏–∫–ª
        start = high_resolution_clock::now();
        volatile long long large = 0;
        for (long long i = 0; i < 100000000; i++) { large++; }
        end = high_resolution_clock::now();
        ms = duration_cast<milliseconds>(end - start).count();
        cout << "   100 –º–ª–Ω –∏—Ç–µ—Ä–∞—Ü–∏–π: " << ms << " –º—Å" << endl;
        cout << "   –°–∫–æ—Ä–æ—Å—Ç—å: " << (100000000 * 1000 / ms) << " ops/sec" << endl;
    }
    
    void executeLine(const string& line, int indent = 0) {
        string l = trim(line);
        if (l.empty() || l[0] == '#') return;
        
        // –ù–û–í–ê–Ø –ö–û–ú–ê–ù–î–ê: count
        if (l.substr(0, 5) == "count") {
            executeCount(l);
            return;
        }
        
        // –ù–û–í–ê–Ø –ö–û–ú–ê–ù–î–ê: bench
        if (l.substr(0, 5) == "bench") {
            executeBench(l);
            return;
        }
        
        // –ù–û–í–ê–Ø –ö–û–ú–ê–ù–î–ê: speed
        if (l == "speed") {
            executeSpeed();
            return;
        }
        
        // –ö–æ–º–∞–Ω–¥–∞ s() - –≤—ã–≤–æ–¥
        if (l.substr(0, 2) == "s(" && l.back() == ')') {
            string text = l.substr(2, l.length() - 3);
            // –¶–≤–µ—Ç–∞
            if (text.find("{red}") != string::npos) {
                while (text.find("{red}") != string::npos)
                    text.replace(text.find("{red}"), 5, RED);
                text += RESET;
            }
            if (text.find("{green}") != string::npos) {
                while (text.find("{green}") != string::npos)
                    text.replace(text.find("{green}"), 7, GREEN);
                text += RESET;
            }
            if (text.find("{blue}") != string::npos) {
                while (text.find("{blue}") != string::npos)
                    text.replace(text.find("{blue}"), 6, BLUE);
                text += RESET;
            }
            for (int i = 0; i < indent; i++) cout << "  ";
            cout << text << endl;
            return;
        }
        
        // –ö–æ–º–∞–Ω–¥–∞ set
        if (l.substr(0, 3) == "set") {
            size_t eq_pos = l.find('=');
            if (eq_pos != string::npos) {
                string var_name = trim(l.substr(3, eq_pos - 3));
                string expr = trim(l.substr(eq_pos + 1));
                
                double value = evaluateExpression(expr);
                variables[var_name] = value;
                
                if (debug_mode) {
                    cout << "  [DEBUG] " << var_name << " = " << value << endl;
                }
            }
            return;
        }
        
        // –ö–æ–º–∞–Ω–¥–∞ print
        if (l.substr(0, 5) == "print") {
            string var_name = trim(l.substr(5));
            if (var_name == "counter") {
                for (int i = 0; i < indent; i++) cout << "  ";
                cout << loop_counter << endl;
            }
            else if (variables.find(var_name) != variables.end()) {
                for (int i = 0; i < indent; i++) cout << "  ";
                cout << variables[var_name] << endl;
            }
            return;
        }
        
        // –û—Å—Ç–∞–ª—å–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã (help, debug –∏ —Ç.–¥.)
        if (l == "help") {
            cout << GREEN << "\n=== Z# –ö–û–ú–ê–ù–î–´ ===" << RESET << endl;
            cout << "  s(text)        - –≤—ã–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞" << endl;
            cout << "  set x = 5      - –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è" << endl;
            cout << "  print x        - –≤—ã–≤–æ–¥ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π" << endl;
            cout << YELLOW << "  –ù–û–í–´–ï –ö–û–ú–ê–ù–î–´:" << RESET << endl;
            cout << "  count 1000000  - –ø–æ–¥—Å—á–µ—Ç –¥–æ —á–∏—Å–ª–∞" << endl;
            cout << "  count to 1e8   - –ø–æ–¥—Å—á–µ—Ç –¥–æ 100 –º–ª–Ω" << endl;
            cout << "  count from 10 to 1000 - –¥–∏–∞–ø–∞–∑–æ–Ω" << endl;
            cout << "  bench 1000000  - –±–µ–Ω—á–º–∞—Ä–∫" << endl;
            cout << "  speed          - —Ç–µ—Å—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏" << endl;
            cout << "  repeat(N) ... end - —Ü–∏–∫–ª" << endl;
            cout << "  debug on/off   - –æ—Ç–ª–∞–¥–∫–∞" << endl;
            cout << "  vars           - –ø–æ–∫–∞–∑–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ" << endl;
            cout << "  exit           - –≤—ã—Ö–æ–¥" << endl;
            return;
        }
        
        if (l == "vars") {
            cout << "\n–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ:" << endl;
            for (const auto& var : variables) {
                cout << "  " << var.first << " = " << var.second << endl;
            }
            return;
        }
        
        if (l == "debug on") {
            debug_mode = true;
            cout << "Debug mode ON" << endl;
            return;
        }
        
        if (l == "debug off") {
            debug_mode = false;
            cout << "Debug mode OFF" << endl;
            return;
        }
    }
    
    void runProgram(const string& program_text) {
        vector<string> lines;
        stringstream ss(program_text);
        string line;
        
        while (getline(ss, line)) {
            if (!trim(line).empty()) {
                lines.push_back(line);
            }
        }
        
        auto start_time = high_resolution_clock::now();
        line_count = 0;
        
        int i = 0;
        while (i < lines.size()) {
            string l = trim(lines[i]);
            line_count++;
            
            if (l.substr(0, 7) == "repeat(" && l.back() == ')') {
                string num_str = l.substr(7, l.length() - 8);
                int repeat_count = (int)evaluateExpression(num_str);
                
                vector<string> block;
                i++;
                
                while (i < lines.size()) {
                    string current = lines[i];
                    string trimmed = trim(current);
                    
                    if (trimmed == "end") {
                        i++;
                        break;
                    }
                    
                    block.push_back(current);
                    i++;
                }
                
                for (int r = 0; r < repeat_count; r++) {
                    loop_counter = r;
                    for (const string& block_line : block) {
                        executeLine(block_line, 1);
                    }
                }
            }
            else if (l != "end") {
                executeLine(l);
                i++;
            }
            else {
                i++;
            }
        }
        
        auto end_time = high_resolution_clock::now();
        exec_time = duration_cast<microseconds>(end_time - start_time).count() / 1000.0;
        
        cout << GREEN << "\n‚úì –ü—Ä–æ–≥—Ä–∞–º–º–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞" << RESET << endl;
        cout << "  –í—Ä–µ–º—è: " << fixed << setprecision(3) << exec_time << " –º—Å" << endl;
    }
    
    void interactiveMode() {
        string input;
        string current_program;
        
        cout << CYAN << "Z# –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º" << RESET << endl;
        cout << "–í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—É (–ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ = –∑–∞–ø—É—Å–∫, 'exit' = –≤—ã—Ö–æ–¥)" << endl;
        cout << "----------------------------------------" << endl;
        
        while (true) {
            cout << ">>> ";
            getline(cin, input);
            
            if (input == "exit") {
                break;
            }
            else if (input.empty()) {
                if (!current_program.empty()) {
                    runProgram(current_program);
                    current_program.clear();
                    cout << "----------------------------------------" << endl;
                }
            }
            else if (input == "clear") {
                current_program.clear();
                cout << "–ü—Ä–æ–≥—Ä–∞–º–º–∞ –æ—á–∏—â–µ–Ω–∞" << endl;
            }
            else {
                current_program += input + "\n";
            }
        }
    }
};

int main() {
    ZSharp z;
    z.interactiveMode();
    return 0;
